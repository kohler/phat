#include <string>
#include <stdlib.h>
#include <assert.h>
#include <map>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include "mpfd.hh"
#include "json.hh"
#include <netdb.h>
#include <errno.h>
#include "rpc_msg.hh"
//#include "log.hh"

namespace puppet {

////////////////////////////////////////////////////////////////////////////////


class Puppet
{
private:
  msgpack_fd mpfd_;
  pid_t child_process_;
public:
  Puppet();
  ~Puppet();

  // Setup operations
  void spawn(String command);
  tamed void connect(String hostname, int port, tamer::event<> ev);
  void disconnect();

  // Basic operations
  tamed void send_print(String name, tamer::event<> ev);
  tamed void send_die(tamer::event<> ev);
  tamed void send_sleep(int seconds, tamer::event<> ev);

  // Client operations
  tamed void send_getroot(String lhs, tamer::event<> ev);
  tamed void send_open(String lhs, String root, String subpath, tamer::event<> ev);
  // FIXME: the rest...
};


// Setup Operations 

Puppet::Puppet()
{
  child_process_ = 0;
  #ifdef DEBUG
  printf("Puppet created.\n");
  #endif
}

Puppet::~Puppet()
{
  disconnect();
  if(child_process_>0) {
    printf("Sending SIGTERM to process %d\n", child_process_);
    kill(child_process_, SIGTERM);
    waitpid(child_process_,NULL,WEXITED);
  }
  #ifdef DEBUG
  printf("Puppet destroyed.\n");
  #endif
}

void Puppet::spawn(String command)
{
  printf("Spawning '%s'\n", command.c_str());
  if( (child_process_=fork())==0 ) { // child
    //printf("execlp|%s|%s|%s|\n", "sh", "-c", command.c_str());
    execlp("sh","sh","-c",command.c_str(),(char *)NULL);
    exit(0);
  }// else parent
}



tamed void Puppet::connect(String hostname, int port, tamer::event<> ev)
{
  tvars {
    struct in_addr hostip;
    tamer::fd cfd;
    msgpack_fd mpfd;
  }
  #ifdef DEBUG
  printf("Looking up %s:%d\n", hostname.c_str(), port);
  #endif

  { // Required for local variable declaration (in_addr_t a).
    in_addr_t a = inet_addr(hostname.c_str());
    if ( a != INADDR_NONE ) {
      hostip.s_addr = a;
    } else {
      struct hostent* hp = gethostbyname(hostname.c_str());
      if( hp==NULL || hp->h_length != 4 || hp->h_addrtype != AF_INET ) {
        fprintf(stderr,"Can't find %s: '%s'\n", hostname.c_str(), strerror(errno));
        exit(-1);
      }
      hostip = *((struct in_addr*) hp->h_addr);
    }
  }
  
  #ifdef DEBUG
  printf("Connecting to %d:%d\n", hostip.s_addr, port);
  #endif

  twait { tamer::tcp_connect(hostip, port, make_event(cfd)); }
  if( !cfd ) {
    fprintf(stderr,"Couldn't connect to %s: '%s'\n", hostname.c_str(), strerror(-cfd.error()));
    exit(-1);
  }

  mpfd_.initialize(cfd);

  ev();
}

void Puppet::disconnect()
{
  #ifdef DEBUG
  printf("Disconnecting\n");
  #endif
}

// Basic operations

tamed void Puppet::send_print(String name, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("print"),name));
    RPC_Msg reply;
  }

  #if DEBUG
  printf("Sending print\n");
  #endif

  twait { mpfd_.call(request,make_event(reply.json())); }
  // FIXME: validate
  // FIXME: assert not NACK
  ev();
}

tamed void Puppet::send_die(tamer::event<> ev){
  tvars {
    Json msg;
  }
  #if DEBUG
  printf("Sending die\n");
  #endif

  msg = Json::array(String("die"));
  //msg = Json::array(String("die"));
  std::cout << "request: " << msg << std::endl;
  mpfd_.write(msg);
  std::cout << "request: " << msg << std::endl;
  ev();
}

tamed void Puppet::send_sleep(int seconds, tamer::event<> ev)
{
  #if DEBUG
  printf("Sending sleep\n");
  #endif
  ev();
}

// Client Operations

tamed void Puppet::send_getroot(String lhs, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("getroot"))); // FIXME: lhs
    RPC_Msg reply;
  }
  #if DEBUG
  printf("Sending getroot\n");
  #endif

  twait { mpfd_.call(request,make_event(reply.json())); }
  std::cout << "Received: " << reply.json() << "\n";
  // FIXME: validate
  // FIXME: assert not NACK

  ev();
}

tamed void Puppet::send_open(String lhs, String root, String subpath, tamer::event<> ev)
{
  #if DEBUG
  printf("Sending open\n");
  #endif

  ev();
}

#if 0
int Puppet::send_mkfile(String lhs, String root, String subpath, String data)
{
  #if DEBUG
  printf("Sending mkfile\n");
  #endif
  return 0;
}

int Puppet::send_mkdir(String lhs, String root, String subpath)
{
  #if DEBUG
  printf("Sending mkdir\n");
  #endif
  return 0;
}

int Puppet::send_getcontents(String lhs, String handle)
{
  #if DEBUG
  printf("Sending getcontents\n");
  #endif
  return 0;
}

int Puppet::send_putcontents(String lhs, String handle, String data)
{
  #if DEBUG
  printf("Sending putcontents\n");
  #endif
  return 0;
}

int Puppet::send_readdir(String lhs, String handle)
{
  #if DEBUG
  printf("Sending readdir\n");
  #endif
  return 0;
}
#endif


////////////////////////////////////////////////////////////////////////////////
// Puppet Server

#define WATCHDOG_TIMER 1

class Puppet_Server
{
private:
  tamer::fd listen_fd;
  tamer::fd client_fd;
  String s;
public:
  Puppet_Server(int port);

  // Basic operations
  tamed void run_puppet_server(int port);
  tamed void read_and_dispatch();
  void dispatch(String tag, Json args); // called from above, but extensible.

  // Remote operations
  tamed void service_print(Json args);
  tamed void service_die(Json args);
  tamed void service_sleep(Json args);
  //int service_print(String name);
  //int service_die();
  //int service_sleep(int seconds);

  // Phat Client operations
  //int service_getroot(String lhs);
  //int service_open(String lhs, String root, String subpath);
  //int service_mkfile(String lhs, String root, String subpath, String data);
  //int service_mkdir(String lhs, String root, String subpath);
  //int service_getcontents(String lhs, String handle);
  //int service_putcontents(String lhs, String handle, String data);
  //int service_readdir(String lhs, String handle);

};

Puppet_Server::Puppet_Server(int port=15808)
{
  printf("Asked for %d\n", port);
  run_puppet_server(port);
}

tamed void Puppet_Server::run_puppet_server(int port)
{
  #ifdef DEBUG
  printf("Puppet alive, trying port %d.\n",port);
  #endif
  listen_fd = tamer::tcp_listen(port);
  if( !listen_fd ) {
    fprintf(stderr,"Puppet failed to listen: %s.\n",strerror(-listen_fd.error()));
    exit(-1);
  }
  #ifdef DEBUG
  printf("Puppet listening.\n");
  #endif
  while(listen_fd) {
    twait {
      listen_fd.accept(make_event(client_fd));
    }
    read_and_dispatch();
  }
}

tamed void Puppet_Server::read_and_dispatch()
{
  tvars {
    msgpack_fd mpfd;
    RPC_Msg request, reply;
    String tag;
  }

  mpfd.initialize(client_fd);
  #ifdef DEBUG
  printf("Puppet received connection\n");
  #endif

  while(client_fd) {
    twait{ mpfd.read_request(tamer::make_event(request.json())); }
    if(!mpfd)
      break;
    if(request.validate() ) {
      reply = RPC_Msg(Json::array(String("ACK")),request);
    } else {
      reply = RPC_Msg(Json::array(String("NACK")),request);
      continue; // Don't dispatch on invalid RPCs.
    }
    // FIXME:
    // This is a little odd. We write the reply *first*, before the
    // action has been taken. This is because some of the operations
    // do not return or block. We want to be able to make progress
    // in the puppet server. There is probably a better way to do this.
    mpfd.write(reply);
    std::cout << "request: " << request.json() << std::endl;
    tag = request.content()[0].as_s();
    dispatch(tag,request.content());
  }
  client_fd.close();
}

void Puppet_Server::dispatch(String tag, Json args)
{
  if(tag=="print")
      service_print(args);
  else if(tag=="sleep")
      service_sleep(args);
  else if(tag=="die")
      service_die(args);
  // No warning about unknown messages, to allow extensibility via inheritance
}

void Puppet_Server::service_print(Json args)
{
  #ifdef DEBUG
  printf("Puppet printing.\n");
  #endif
  std::cout << args[1] << "\n";
}

void Puppet_Server::service_die(Json args)
{
  #ifdef DEBUG
  printf("Puppet dying.\n");
  #endif
  exit(0);
}

tamed void Puppet_Server::service_sleep(Json args)
{
  tvars {
    int i;
  }
  if( !args[1].is_i() ) {
    return;
  }
  i = args[1].as_i();
  assert((i>0) && (i<1000) && "Ridiculous sleep time requested. Corruption?\n");
  #ifdef DEBUG
  printf("Puppet sleeping.\n");
  #endif
  twait { tamer::at_delay(i,make_event()); }
}

} // namespace puppet
