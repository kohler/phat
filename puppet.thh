#include <string>
#include <stdlib.h>
#include <assert.h>
#include <map>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include "mpfd.hh"
#include "json.hh"
#include <netdb.h>
#include <errno.h>
#include "rpc_msg.hh"
#include "log.hh"
#include "network.hh"

namespace puppet {

////////////////////////////////////////////////////////////////////////////////


class Puppet
{
private:
  msgpack_fd mpfd_;
  pid_t child_process_;
public:
  Puppet();
  ~Puppet();

  // Setup operations
  void spawn(String command);
  tamed void connect(String hostname, int port, tamer::event<> ev);
  void disconnect();

  // Basic operations
  tamed void send_print(String name, tamer::event<> ev);
  tamed void send_die(tamer::event<> ev);
  tamed void send_sleep(int seconds, tamer::event<> ev);

  // Client operations
  tamed void send_getroot(String lhs, tamer::event<> ev);
  tamed void send_open(String lhs, String root, String subpath, tamer::event<> ev);
  tamed void send_mkfile(String lhs, String path, String data, tamer::event<> ev);
  tamed void send_mkdir(String lhs, String path, tamer::event<> ev);
  tamed void send_getcontents(String lhs, String path, tamer::event<> ev);
  tamed void send_putcontents(String lhs, String path, String data, tamer::event<> ev);
  tamed void send_readdir(String lhs, String path, tamer::event<> ev);
  tamed void send_stat(String lhs, String path, tamer::event<> ev);
  tamed void send_remove(String lhs, String path, tamer::event<> ev);
  // FIXME: the rest...
};


// Setup Operations 

Puppet::Puppet()
{
  child_process_ = 0;
  INFO() << "Puppet created.";
}

Puppet::~Puppet()
{
  disconnect();
  if(child_process_>0) {
    INFO() << "Sending SIGTERM to process " << child_process_;
    kill(child_process_, SIGTERM);
    waitpid(child_process_,NULL,WEXITED);
  }
  INFO() << "Puppet destroyed.";
}

void Puppet::spawn(String command)
{
  INFO() << "Spawning " << command;
  if( (child_process_=fork())==0 ) { // child
    execlp("sh","sh","-c",command.c_str(),(char *)NULL);
    exit(0);
  } // else parent
}



tamed void Puppet::connect(String hostname, int port, tamer::event<> ev)
{
  tvars {
    struct in_addr hostip;
    tamer::fd cfd;
    msgpack_fd mpfd;
  }
  INFO() << "Looking up " << hostname << ":" << port;

  if( !get_ip_address( hostname.c_str(), hostip ) ) {
    ERROR() << "Can't find " << hostname << ": " << strerror(errno);
    exit(-1);
  }
  
  INFO() << "Connecting to " << inet_ntoa(hostip) << ":" << port;

  twait { tamer::tcp_connect(hostip, port, make_event(cfd)); }
  if( !cfd ) {
    ERROR() << "Couldn't connect to " << hostname << ": " << strerror(-cfd.error());
    exit(-1);
  }

  mpfd_.initialize(cfd);

  ev();
}

void Puppet::disconnect()
{

}

// Basic operations

tamed void Puppet::send_print(String name, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("print"),name));
    RPC_Msg reply;
  }

  INFO() << "Sending puppet command: print";

  twait { mpfd_.call(request,make_event(reply.json())); }

  // FIXME: validate
  // FIXME: assert not NACK
  ev();
}

tamed void Puppet::send_die(tamer::event<> ev){
  tvars {
    Json msg;
  }

  INFO() << "Sending puppet command: die";

  // FIXME

  ev();
}

tamed void Puppet::send_sleep(int seconds, tamer::event<> ev)
{
  INFO() << "Sending puppet command: sleep";

  // FIXME

  ev();
}

// Client Operations

tamed void Puppet::send_getroot(String lhs, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("getroot"))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() << "Sending puppet command: getroot";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();

  // FIXME: validate
  // FIXME: assert not NACK

  ev();
}

tamed void Puppet::send_open(String lhs, String root, String subpath, tamer::event<> ev)
{
  INFO() << "Sending puppet command: open";

  ev();
}

tamed void Puppet::send_mkfile(String lhs, String path, String data, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("mkfile"),Json::array(path,data))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: mkfile";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_mkdir(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("mkdir"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: mkdir";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_getcontents(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("getcontents"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: getcontents";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_putcontents(String lhs, String path,String data, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("putcontents"),Json::array(path,data))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: putcontents";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_readdir(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("readdir"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: readdir";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_stat(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("stat"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: stat";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_remove(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("remove"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: remove";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}

////////////////////////////////////////////////////////////////////////////////
// Puppet Server

#define WATCHDOG_TIMER 1

class Puppet_Server
{
private:
  tamer::fd listen_fd;
  tamer::fd client_fd;
  String s;
public:
  Puppet_Server(int port);

  // Basic operations
  tamed void run_puppet_server(int port);
  tamed void read_and_dispatch();
  void dispatch(String tag, Json args); // called from above, but extensible.

  // Remote operations
  tamed void service_print(Json args);
  tamed void service_die(Json args);
  tamed void service_sleep(Json args);
  //int service_print(String name);
  //int service_die();
  //int service_sleep(int seconds);

  // Phat Client operations
  //int service_getroot(String lhs);
  //int service_open(String lhs, String root, String subpath);
  //int service_mkfile(String lhs, String root, String subpath, String data);
  //int service_mkdir(String lhs, String root, String subpath);
  //int service_getcontents(String lhs, String handle);
  //int service_putcontents(String lhs, String handle, String data);
  //int service_readdir(String lhs, String handle);

};

Puppet_Server::Puppet_Server(int port=15808)
{
  run_puppet_server(port);
}

tamed void Puppet_Server::run_puppet_server(int port)
{
  listen_fd = tamer::tcp_listen(port);
  if( !listen_fd ) {
    ERROR() << "Puppet failed to listen: " << strerror(-listen_fd.error());
    exit(-1);
  }
  INFO() << "Puppet listening on port " << port;

  while(listen_fd) {
    twait {
      listen_fd.accept(make_event(client_fd));
    }
    read_and_dispatch();
  }
}

tamed void Puppet_Server::read_and_dispatch()
{
  tvars {
    msgpack_fd mpfd;
    RPC_Msg request, reply;
    String tag;
  }

  mpfd.initialize(client_fd);
  INFO() << "Puppet received connection";

  while(client_fd) {
    twait{ mpfd.read_request(tamer::make_event(request.json())); }
    if(!mpfd)
      break;
    if(request.validate() ) {
      reply = RPC_Msg(Json::array(String("ACK")),request);
    } else {
      reply = RPC_Msg(Json::array(String("NACK")),request);
      continue; // Don't dispatch on invalid RPCs.
    }
    // FIXME:
    // This is a little odd. We write the reply *first*, before the
    // action has been taken. This is because some of the operations
    // do not return or block. We want to be able to make progress
    // in the puppet server. There is probably a better way to do this.
    mpfd.write(reply);
    tag = request.content()[0].as_s();
    dispatch(tag,request.content());
  }
  client_fd.close();
}

void Puppet_Server::dispatch(String tag, Json args)
{
  if(tag=="print")
      service_print(args);
  else if(tag=="sleep")
      service_sleep(args);
  else if(tag=="die")
      service_die(args);
  // No warning about unknown messages, to allow extensibility via inheritance
}

void Puppet_Server::service_print(Json args)
{
  INFO() << "Puppet printing";

  std::cout << args[1] << "\n";
}

void Puppet_Server::service_die(Json args)
{
  INFO() << "Puppet dying";

  exit(0);
}

tamed void Puppet_Server::service_sleep(Json args)
{
  tvars {
    int i;
  }
  if( !args[1].is_i() ) {
    return;
  }
  i = args[1].as_i();
  assert((i>0) && (i<1000) && "Ridiculous sleep time requested. Corruption?\n");
  INFO() << "Puppet sleeping.";

  twait { tamer::at_delay(i,make_event()); }
}

} // namespace puppet
