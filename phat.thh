#ifndef PHAT_HH
#define PHAT_HH

#include "mpfd.hh"
#include "string.hh"
#include <tamer/tamer.hh>
#include <vector>
#include <map>

namespace phat {
class Handle;

class Metadata {
};

class Sequencer {
};

enum LockType { write = 0, read = 1 };

class Phat {
  public:
    Phat();
    tamed void connect(String host, uint32_t port, tamer::event<> done);

    tamed void getRoot(tamer::event<Handle*, int32_t> done);
    tamed void open(Handle* handle, String subpath, 
                    tamer::event<Handle*, int32_t> done);
    tamed void mkfile(Handle* handle, String subpath, String initialdata, 
                      tamer::event<Handle*, int32_t> done);
    tamed void mkdir(Handle* handle, String subpath, 
                     tamer::event<Handle*, int32_t> done);
    tamed void getcontents(Handle* handle, tamer::event<String, int32_t> done);
    tamed void putcontents(Handle* handle, String data, tamer::event<int32_t> done);
    tamed void readdir(Handle* handle, tamer::event<std::vector<String>, int32_t> done);
    tamed void stat(Handle* handle, tamer::event<Metadata*, int32_t> done);
    tamed void flock(Handle* handle, const LockType& type, 
                     tamer::event<Sequencer*, int32_t> done);
    tamed void funlock(Handle* handle, tamer::event<Sequencer*, int32_t> done);
    tamed void remove(Handle* handle, tamer::event<int32_t> done);

  private:
    msgpack_fd* mpfd_;
    std::map<String, Handle*> open_;
};

class Handle {
  public:
    inline Handle(String path);

    inline const String& path() const;

  private:
    String path_;

    // cache
    String contents_;
    Metadata* meta_;
    Sequencer* lock_;
    std::vector<String> children_;

    friend class Phat;
};


inline Handle::Handle(String path) 
    : path_(path), meta_(nullptr), lock_(nullptr) {
}

inline const String& Handle::path() const {
    return path_;
}

}

#endif
